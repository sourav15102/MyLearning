
**Q: Difference between package, class and project?**
A:
A **project** is an IDE-level grouping; its a set of source files, configurations, assets, ect. that make up a working application.
A **package**, on the other hand, is a grouping of related classes/source files, it provides Namespace. It is a way of organizing your code, and also works as the addressing scheme used by Java to find code you are importing.
A **Library**, set of packages, provides a functionality.
A **Class**: blueprint of an object

**Q: Compilation vs execution**
A:
**Compilation is the process of converting the Java source code into an executable form, known as bytecode.** **Interpretation is the process of executing the Java bytecode directly by the JVM**


**Q: what is javap command?**
A:
The `javap` command disassembles one or more class files. The output depends on the options used. When no options are used, the `javap` command prints the protected and public fields, and methods of the classes passed to it.
The **_javap_** command displays information about the fields, constructors, and methods of a class.
It is used after compiling the java file.
it runs with `javap ABC.class` NOT `javap ABC.java`.

Q: What is `.equals` contract.
A:
- _reflexive_: an object must equal itself
- _symmetric_: _x.equals(y)_ must return the same result as _y.equals(x)_
- _transitive_: if _x.equals(y)_ and _y.equals(z),_ then also _x.equals(z)_
- _consistent_: the value of ._equals()_ should change only if a property that is contained in ._equals()_ changes (no randomness allowed)

Q: What is `.hashcode` contract.
A: All three criteria in the ._hashCode()_ contract mention the ._equals()_ method in some way**:**
- _internal consistency_: the value of _hashCode()_ may only change if a property that is in _equals()_ changes
- _equals consistency_: objects that are equal to each other must return the same hashCode
- _collisions_: unequal objects may have the same hashCode

Q: Why always override hashcode with equals
A:
Joshua Bloch says on Effective Java

> You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable.

Let's try to understand it with an example of what would happen if we override `equals()` without overriding `hashCode()` and attempt to use a `Map`.

Say we have a class like this and that two objects of `MyClass` are equal if their `importantField` is equal (with `hashCode()` and `equals()` generated by eclipse)

```java
public class MyClass {
    private final String importantField;
    private final String anotherField;

    public MyClass(final String equalField, final String anotherField) {
        this.importantField = equalField;
        this.anotherField = anotherField;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result
                + ((importantField == null) ? 0 : importantField.hashCode());
        return result;
    }

    @Override
    public boolean equals(final Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        final MyClass other = (MyClass) obj;
        if (importantField == null) {
            if (other.importantField != null)
                return false;
        } else if (!importantField.equals(other.importantField))
            return false;
        return true;
    }
}
```

---

Imagine you have this

```java
MyClass first = new MyClass("a","first");
MyClass second = new MyClass("a","second");
```

**Override only `equals`**

If only `equals` is overriden, then when you call `myMap.put(first,someValue)` first will hash to some bucket and when you call `myMap.put(second,someOtherValue)` it will hash to some other bucket (as they have a different `hashCode`). So, although they are equal, as they don't hash to the same bucket, the map can't realize it and both of them stay in the map.

**Q: == vs .equals**
A:
Generally:
1. `equals(...)` method compares exactly what it's coded to compare, no more or less.
2. If a class doesn't override `equals`, it uses the closest parent class's `equals(Object o)` method that's overridden.
3. If no parent class overrides it, it defaults to `Object#equals(Object o)`, which checks if references are the same `==`.
4. Always override `hashCode` if you override `equals` to maintain the contract: `hashCode` must be same for equivalent objects.
5. `hashCode` ensures consistency between object equality and hash-based data structures.
6. HOWEVER, with Integer, Double, they will act like int , double only.
	1. because:
	2. `Integer x = 1`, looks like `Integer x = Integer.valueOf(1)` inside.
	3. and `a==b` looks like `a.intValue() == b` inside.
7. Above will work for Integer, Long, Boolean etc, but not for Double, cos Double doesnt use pooling.
String perspective:
- String has implemented equals as they will check for values of string.
- `==` will check for object reference as usual.

BUT:
- if we are talking about primitive data types like int, then it will check for values directly.



Q: How to print without semicolon?
A:
```java
if(System.out.printf("hello"+"\n")!=null)
{}
```
Q: Why printf works but not println?
A: cos `printf` returns `PrintWriter` which you can compare to `null`. `println` returns `void` i.e. nothing which you can't compare to null

Q: How to create objects without new keyword?
A:
```java
Class<YourClass> c = YourClass.class;
YourClass instance = c.newInstance();
```

Q: strictfp keyword?
A:
**strictfp" Keyword in Java:**
- "strictfp" is a Java keyword used with classes, interfaces, and methods.
- It ensures that floating-point calculations in the marked code are performed precisely as defined by the IEEE 754 standard, regardless of the underlying platform.
- It's often used in situations where strict control over floating-point precision is necessary, such as financial applications.
- When applied to a class or interface, all methods within it become "strictfp."
- When applied to a method, only that specific method's calculations follow strict precision rules.
```java
strictfp class MyClass {
    // All methods in this class will follow strict floating-point rules
    strictfp void myMethod() {
        // This method adheres to strictfp rules
    }
}
```

Q: System class:
A: 
1. **Standard Input and Output:**
   ```java
   // Reading from standard input
   Scanner scanner = new Scanner(System.in);
   System.out.println("Enter your name:");
   String name = scanner.nextLine();
   System.out.println("Hello, " + name);

   // Writing to standard output
   System.out.println("This is a message to standard output.");
   ```
2. **Error Output Stream:**
   ```java
   // Writing to the error output stream
   System.err.println("This is an error message.");
   ```
3. **Utility Method to Copy Array:**
   ```java
   // Using arraycopy method to copy an array
   int[] sourceArray = {1, 2, 3, 4, 5};
   int[] destinationArray = new int[5];
   System.arraycopy(sourceArray, 0, destinationArray, 0, sourceArray.length);
   ```
```java
source_array : 10 20 30 40 50 60 70 80 90 100 
sourcePos : 3
dest_array : 15 25 35 45 55 65 75 85 95 105 
destPos : 5
len : 4
final dest_array : 15 25 35 45 55 40 50 60 70 105
```
1. **Utilities to Load Files and Libraries:**
   ```java
   // Loading a file using FileInputStream
   FileInputStream fileInputStream = new FileInputStream("example.txt");

   // Loading a library using System.loadLibrary
   System.loadLibrary("myLibrary");
   ```
5. **Static Fields of System Class:**
   ```java
   // Accessing static fields of System class
   InputStream standardInput = System.in;
   PrintStream errorOutput = System.err;
   PrintStream standardOutput = System.out;
   ```

Q: Singleton class
A:
```java
- class Singleton{  
-     private static Singleton single_instance = null;  
-     int i;  
-      private Singleton ()  
-      {  
-          i=90;  
-      }  
-      public static Singleton getInstance()  
-      {  
-          if(single_instance == null)  
-          {  
-              single_instance = new Singleton();  
-          }  
-          return single_instance;  
-      }  
- }  
- public class Main   
- {  
-     public static void main (String args[])  
-     {  
-         Singleton first = Singleton.getInstance();  
-         System.out.println("First instance integer value:"+first.i);  
-         first.i=first.i+90;  
-         Singleton second = Singleton.getInstance();  
-         System.out.println("Second instance integer value:"+second.i);  
-     }  
- }
```
Q: Applet?
A:
An applet is a small Java program that runs inside a web browser to generate dynamic content. It operates on the client side and is embedded within webpages, with the help of plugins.
When an applet is created, the following methods are invoked in order.
- init()
- start()
- paint()
When an applet is destroyed, the following functions are invoked in order.
- stop()
- destroy()

Q: Locale?
A:
```java
1. import java.util.*;  
2. public class LocaleExample {  
3. public static void main(String[] args) {  
4. Locale locale=Locale.getDefault();  
5. //Locale locale=new Locale("fr","fr");//for the specific locale  

7. System.out.println(locale.getDisplayCountry());  
8. System.out.println(locale.getDisplayLanguage());  
9. System.out.println(locale.getDisplayName());  
10. System.out.println(locale.getISO3Country());  
11. System.out.println(locale.getISO3Language());  
12. System.out.println(locale.getLanguage());  
13. System.out.println(locale.getCountry());  

15. }  
16. }
```
